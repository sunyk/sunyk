package com.concurrent.read.myquestion;

/**
 * created on sunyang 2018/7/16 14:14
 * Are you different!"jia you" for me
 */
public class Cas {
    /**
     * 在java中java.util.concurrent.atomic包下面的原子变量类就是使用乐观锁的一种实现方式CAS实现的。
     *
     * cas是比较和交换，默认是乐观锁思想的一种实现方式，操作一个
     * CAS的其实和乐观锁的冲突检查+数据更新的原理是一样的。
     * 什么是ABA问题？
     * 线程1从内存位置V中取出A，此时线程2从内存取出A，并且对其进行修改操作B，然后再将其该会A，此时线程1进行CAS操作发现内存中仍然是A，然后线程1操作成功。
     * 尽管线程1的CAS操作成功，单可能存在着丢失的潜在问题。
     * 单链表实现的堆栈，栈顶A，这时T1已经找到A.next为B，希望通过CAS将栈顶替换为B，head.compareAndSet(A,B);
     * 在T1执行前，T2介入，将A,B出栈，在push进去D,C,A，此时对象B处于游离状态。
     * 此时轮到T1执行CAS操作，检测发现栈顶仍未A，所有CAS成功，栈顶变成B，但实际上B.next为null，此时堆栈中只有B一个元素，C和D组成的链表不再存在堆栈中，无故丢失C,D。
     * 此现象就是ABA问题
     * 会引起ABA问题，解决方案是java1.5JDK有一个atomicStampedReference类解决。
     * 怎么解决的？
     * 这个类的compareAndSet方法是首先检查当前引用是否等于预期引用，并且当前标志等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
     * cas是在线程少量冲突使用，因为失败了会一直重试，直至成功，性能消耗高
     * synchronize是1.6以后做了很大优化，在线程少量冲突时使用，可以获得和cas类似的性能，但是在冲突严重的情况，synchronize性能远高于CAS。
     *
     *
     *
     *
     *
     *
     * 对象在内存中的布局分为三块区域：
     * 对象头：顶部
     * 实例变量：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。
     * 填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐
     *
     *
     *
     *
     *
     *
     *
     *
     *
     * Java调用new object()会创建一个对象，这个对象会被分配到JVM的堆中。那么这个对象到底是怎么在堆中保存的呢？
     * 1.首先，new object()执行的时候，这个对象需要多大的空间，其实是已经确定的，因为java中的各种数据类型，占用多大的空间都是固定的，
     * 那么接下来的工作就是在堆中找出那么一块空间用于存放这个对象。
     * 在单线程的情况下，一般有两种分配策略：
     * 1. 指针碰撞：这种一般适用于内存是绝对规整的（内存是否规整取决于内存回收策略），分配空间的工作只是将指针像空闲内存一侧移动对象大小的距离即可。
     * 2. 空闲列表：这种适用于内存非规整的情况，这种情况下JVM会维护一个内存列表，记录哪些内存区域是空闲的，大小是多少。
     * 给对象分配空间的时候去空闲列表里查询到合适的区域然后进行分配即可。
     *          问题来了----------
     * 但是JVM不可能一直在单线程状态下运行，那样效率太差了。由于再给一个对象分配内存的时候不是原子性的操作，至少需要以下几步：
     * 查找空闲列表、分配内存、修改空闲列表等等，这是不安全的。解决并发时的安全问题也有两种策略：
     *1. CAS：实际上虚拟机采用CAS配合上失败重试的方式保证更新操作的原子性，原理和上面讲的一样。
     * 2. TLAB：如果使用CAS其实对性能还是会有影响的，所以JVM又提出了一种更高级的优化策略：每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区（TLAB），
     * 线程内部需要分配内存时直接在TLAB上分配就行，避免了线程冲突。只有当缓冲区的内存用光需要重新分配内存的时候才会进行CAS操作分配更大的内存空间。
     * 虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来进行配置（jdk5及以后的版本默认是启用TLAB的）。
     */
}
