package com.concurrent.read.myquestion;

/**
 * created on sunyang 2018/7/19 11:32
 * Are you different!"jia you" for me
 */
public class Volatile {
    /*
     理解Java内存区域与Java内存模型
            Java内存区域
            Java内存模型概述
     硬件内存架构与Java内存模型
            硬件内存架构
            Java线程与硬件处理器
            Java内存模型与硬件内存架构的关系
     JMM存在的必要性
     Java内存模型的承诺
            原子性
            理解指令重排
                编译器重排
                处理器指令重排
            可见性
            有序性
            JMM提供的解决方案
            理解JMM中的happens-before 原则
      volatile内存语义
            volatile的可见性
            volatile禁止重排优化
     */

    /**
     * Java内存区域
     * 所有线程共享的数据区域：方法区method area和堆java heap
     * 每个线程的私有数据区域： 虚拟机栈 vm stack，本地方法栈 native method stack，程序计数器
     *
     * 方法区：
     * 方法区属于线程共享的内存区域，又称Non-Heap非堆，主要用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据，根据java虚拟机规范的规定，
     * 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。
     * 值得注意的是在方法区中存在一个叫运行时常量池的区域，它主要用于存放编译器生成的各种字面量和符号引用，这些内容将在类加载后存放到运行时常量池中，以便后续使用。
     * JVM堆：
     * Java堆也是属于线程共享的内存区域，它在虚拟机启动时创建，是Java虚拟机所管理的内存中最大的一块，主要用于存放对象实例，几乎所有的对象实例都在这里分配内存，
     * 注意Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做GC堆，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。
     * 程序计数器：
     * 属于线程私有的数据区域，是一小块内存空间，主要代表当前线程所执行的字节码行号指示器。字节码解释器工作时，通过改变这个计数器的值来选取下一条需要执行的字节码指令，
     * 分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。
     *
     * 虚拟机栈：
     * 属于线程私有的数据区域，与线程同时创建，总数与线程关联，代表Java方法执行的内存模型。每个方法执行时都会创建一个栈帧来存储方法的变量表，操作数栈，动态链接方法，返回值，
     * 返回地址等信息。每个方法从调用到结束就对于一个栈帧在虚拟机栈中的入栈和出栈过程；
     * 本地方法栈：
     * 本地方法栈属于线程私有数据区域，这部分主要与虚拟机用到的Native方法相关，一般情况下，我们无需关心区域。
     *
     * Java内存模型
     * Java内存模型即Java memory model简称JMM本身是一种抽象的概念，线程，主内存，工作内存三者交互基于JMM。
     * 不同的线程间无法访问对方的工作内存，线程间的通信传值必须通过主内存来完成。
     * 更恰当说JMM描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，JMM是围绕原子性，有序性，可见性展开的。
     * JMM与java内存区域唯一相似点，都存在共享数据区域和私有数据区域，在JMM中主内存属于共享数据区域，从某个程度上讲应该包括了堆和方法区，而工作内存数据线程私有数据区域，
     * 从某个程度上讲则应该包括程序计数器，虚拟机栈以及本地方法栈。或许在某些地方，我们可能会看见主内存被描述为堆内存，工作内存被称为线程栈，实际上他们表达的都是同一个含义。
     * 关于JMM中的主内存和工作内存说明如下：
     * 主内存：
     * 主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量局部变量，当前也包括了共享的类信息，常量，静态变量。
     * 由于共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。
     * 工作内存：
     * 主要存储当前方法的所有本地变量信息，工作内存中存储着住内存中的变量副本拷贝，每个线程只能访问自己的工作内存，即线程中的本地变量对其他线程是不可见的，就算是两个线程
     * 执行的是同一段代码，他们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器，相关native方法的信息。注意由于工作内存是每个线程的私有
     * 数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。
     *
     * 弄清楚主内存和工作内存，
     *
     * Java内存模型的承诺
     * 先来了解几个概念，即原子性？可见性？有序性？最后再阐明JMM是如何保证这3个特性
     * 原子性：
     * 原子性是指一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。
     * 理解指令重排：
     * 计算机在执行程序时，为了提高性能，编译器和处理器的常常会对指令做重排，一般分一下3种
     * 1.编译器优化的重排：
     * 编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
     * 2.指令并行的重排:
     * 现代处理器采用了指令并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应的机器指令的执行顺序。
     * 3.内存系统的重排:
     * 由于处理器使用缓存和读写缓存缓冲区，这使得加载和存储操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。
     *
     * 其中编译器优化的重排属于编译期重排，指令并行的重排和内存系统的重排属于处理器重排；
     * 在多线程环境中，这些重排优化可能会导致程序出现内存可见性问题
     *
     * 处理器指令重排：
     * 先了解一下指令重排的概念，处理器指令重排是对CPU的性能优化，从指令的执行角度来说一条指令可以分为多个步骤完成，如下
     * 取指 IF
     * 译码和取寄存器操作数 ID
     * 执行或者有效地址计算 EX
     * 存储器访问 MEM
     * 写回 WB
     * 因此，请记住，指令重排只会保证单线程中串行语义的执行的一致性，但并不会关心多线程间的语义一致性。
     * 可见性：
     * 理解了指令重排现象后，可见性容易理解，可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。
     * 有序性：
     * 是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，这样的理解并没有毛病，毕竟对于单线程而言确实如此，但对于多线程环境，则可能出现乱序现象，可能会出现指令重排现象。
     * JMM提供的解决方案
     * 在理解了原子性，可见性以及有序性问题后，看JMM是如何保证的，在Java内存模型中都提供一套解决方案供Java工程师在开发过程使用，如原子性问题，除了JVM自身提供的对基本数据类型
     * 读写操作的原子性外，对于方法级别或者代码块级别的原子性操作，可以使用synchronized关键字或者重入锁ReentrantLock保证程序执行的原子性。而工作内存与主内存同步延迟现象导致
     * 的可见性问题，可以使用synchronized关键字或者volatile关键字解决，他们都可以使一个线程修改后的变量立即对其他线程可见。对于指令重排导致的可见性问题和有序性问题，则可以
     * 利用volatile关键字解决，因为volatile的另外一个作用就是禁止重排序优化，除了靠synchronized和volatile关键字来保证原子性，可见性以及有序性外，JMM内部还定义了一套
     * happens-before原则来保证多线程环境下两个操作间的原子性，可见性，以及有序性、
     * 理解JMM中的happens-before原则
     * 在Java内存模型中，还提供了happens-before原则来辅助保证程序执行的原子性，可见性以及有序性的问题，它是判断数据是否存在竞争，线程是否安全的依据，happens-before原则内容如下：
     * 1.程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。
     * 2.锁规则，解锁操作必须发生在后续的同一个锁的加锁之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后同一个锁。
     * 3.volatile规则，volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生
     * 变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。
     * 4.线程启动规则，线程的start（）方法先于他的每一个动作，即如果线程A在执行线程B的start（）方法之前修改了共享变量的值，那么当线程B执行start（）方法时，线程A对共享变量的修改
     * 对线程B可见
     * 5.传递性  A先于B，B先于C，那么A必然先于C
     * 6.线程终止规则， 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，
     * 线程B对共享变量的修改将对线程A可见。
     * 7.线程中断规则，对线程interrupt（）方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。
     * 8.对象终结规则，对象的构造函数执行，结束先于finalize()方法
     * 上述8条原则无需手动添加任何同步手段（synchronized|volatile）即可达到效果，
     * class MixedOrder{
     *     int a = 0;
     *     boolean flag = false;
     *     public void writer(){
     *         a = 1;
     *         flag = true;
     *     }
     *     public void read(){
     *         if(flag){
     *             int i = a + 1;
     *         }
     *     }
     * }
     * 存在两条线程A和B，线程A调用实例对象的writer()方法，而线程B调用实例对象的read()方法，线程A先启动而线程B后启动，那么线程B读取到的i值是多少呢？
     * 现在依据8条原则，由于存在两条线程同时调用，因此程序次序原则不合适。writer()方法和read()方法都没有使用同步手段，锁规则也不合适。
     * 没有使用volatile关键字，volatile变量原则不适应。线程启动规则、线程终止规则、线程中断规则、对象终结规则、传递性和本次测试案例也不合适。
     * 线程A和线程B的启动时间虽然有先后，但线程B执行结果却是不确定，也是说上述代码没有适合8条原则中的任意一条，也没有使用任何同步手段，所以上述的操作是线程不安全的，
     * 因此线程B读取的值自然也是不确定的。
     * 修复这个问题的方式很简单，要么给writer()方法和read()方法添加同步手段，如synchronized或者给变量flag添加volatile关键字，确保线程A修改的值对线程B总是可见。
     * Volatile内存语义
     * volatile在并发编程中很常见，但是也容易被滥用，现在我们就进一步分析volatile关键字的语义。volatile是Java虚拟机提供的轻量级的同步机制。volatile关键字有如下两个作用
     * 1.保证被volatile修饰的共享共享变量对所有线程总数可见的，也就是当一个线程修改了一个被volatile修饰共享变量的值，新值总数可以被其他线程立即得知。
     * 2.禁止指令重排序优化。
     * volatile的可见性
     * 对于increase方法必须使用synchronized修饰，以便保证线程安全，需要注意的是一旦使用synchronized修饰方法后，
     * 由于synchronized本身也具备与volatile相同的特性，即可见性，因此在这样种情况下就完全可以省去volatile修饰变量。
     * JMM会把该线程对应的工作内存置为无效，那么该线程将只能从主内存中重新读取共享变量。
     * volatile变量正是通过这种写-读方式实现对其他线程可见（但其内存语义实现则是通过内存屏障，稍后会说明）。
     * volatile禁止重排优化
     * volatile关键字另一个作用就是禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象。
     * volatile是如何实现禁止指令重排优化的？
     * 内存屏障，又称内存栅栏，是一个CPU指令，他的作用有两个，一是保证特定操作的执行顺序，二是保证某些变量的内存可见性。
     * 由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条memory barrier则会告诉编译器和CPU，不管什么指令都不能合这条memory barrier指令重排序，也就是说通过插入内存
     * 屏障禁止在内存屏障前后的指令执行重排序优化。memory barrier的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。总之，volatile
     * 变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化。
     * 一个非常经典的禁止重排优化的例子DCL
     * public class DoubleCheckLock{
     *     private static DoubleCheckLock instance;
     *     private DoubleCheckLock()}{}
     *     public static DoubleCheckLock getInstance(){
     *         if(instance == null){
     *             synchronized(DoubleCheckLock.class){
     *                 if(instance == null){
     *                     instance = new DoubleCheckLock();
     *                     //memory = allocate(); //1.分配对象内存空间
     *                     //instance(memory);    //2.初始化对象
     *                     //instance = memory;   //3.设置instance指向刚分配的内存地址，此时instance！=null
     *                     多线程下：
     *                     memory = allocate(); //1.分配对象内存空间
     *                     instance = memory;   //3.设置instance指向刚分配的内存地址，此时instance！=null，但是对象还没有初始化完成！
     *                     instance(memory);    //2.初始化对象
     *                     指令重排只会保证串行语义的执行的一致性(单线程)，但并不会关心多线程间的语义一致性。
     *                     //禁止指令重排优化
     *                     private volatile static DoubleCheckLock instance;
     *                 }
     *             }
     *         }
     *         return instance;
     *     }
     * }
     * */
}
