package com.concurrent.read.mysql;

/**
 * created on sunyang 2018/7/23 15:29
 * Are you different!"jia you" for me
 */
public class M3 {
    /**
     *1.什么是分表？
     *对于访问极为频繁且数据量巨大的单表来说，我们首先要做的就是减少单表的记录条数，以便减少数据查询所需要的时间，提高数据库的吞吐，这就是所谓的分表！
     * 场景：
     * 分表只是能够解决单表数据量过大带来的查询效率下降的问题
     * 2.分表策略？
     * 用户id是最常用的分表字段
     * 注：拆分后表的数量一般为2的n次方，就是上面拆分成256张表的由来！
     *
         create table order_(
         order_id bigint(20) primary key auto_increment,
         user_id bigint(20),
         user_nick varchar(50),
         auction_id bigint(20),
         auction_title bigint(20),
         price bigint(20),
         auction_cat varchar(200),
         seller_id bigint(20),
         seller_nick varchar(50)
         )
     那么分表以后，假设user_id = 257,并且auction_id = 100,需要根据auction_id来查询对应的订单信息，则对应的SQL语句如下
     select * from order_1 where user_id=257 and auction_id = 100;
     其中，order_1是根据257%256计算得出，表示分表之后的第一张order表。

     * 3.什么是分库?
     * 对数据库进行拆分，从而提高数据库写入能力，这就是所谓的分库!
     * 场景是什么？
     * 数据库的并发处理能力，面对高并发的读写访问，当数据库master服务器无法承载写操作压力时，不管如果扩展slave服务器，此时都没有意义
     * 4.分库策略？
     * 分库可以采用通过一个关键字取模的方式
     * 还是之前的订单表，假设user_id 字段的值为258，将原有的单库分为256个库，那么应用程序对数据库的访问请求将被路由到第二个库(258%256 = 2)。
     *
     * 5.分库分表
     * 场景：
     * 有时数据库可能既面临着高并发访问的压力，又需要面对海量数据的存储问题，这时需要对数据库既采用分表策略，又采用分库策略，以便同时扩展系统的
     * 并发处理能力，以及提升单表的查询性能，这就是所谓的分库分表。
     * 分库分表的路由策略：
     * 1.中间变量 = user_id % （分库数量 * 每个库的表数量）
     * 2.库 = 取整数（中间变量/每个库的表数量）
     * 3.表 = 中间变量%每个库的表数量
     *分库分表策略详细过程如下：
     * 假设将原来的单库单表order拆分成256个库，每个库包含1024个表，那么按照前面所提到的路由策略，对于user_id=262145 的访问，路由的计算过程如下：
     * 1.中间变量 = 262145 % （256 * 1024） = 1
     * 2.库 = 取整（1/1024）=0
     * 3.表 = 1 % 1024 = 1
     * 对于user_id=262145 的订单记录的查询和修改，将被路由到第0个库的第1个order_1表中执行
     */
}
